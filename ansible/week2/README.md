# Week 2

### Collecting and validating information

The overall object here is to diagramatically represent the current configuration of trunks. This allows for quick troubleshooting and verification, as well as simple requirements gathering when planning manual changes (my test network hasn't implemented config generation and automated implementation, yet).

#### filter_plugins/expand.py
A simple custom filter that takes a string as would come from IOS cli (e.g. 1,10,30,40-45,70) and expands the VLAN ranges, creating a list element for each VLAN. If a list is already provided it returns that list. Could be improved to ensure all elements of the list are ints, and to verify that if the input is not a list, that it is a string or single int. Further, it should also include logic to expand the keywords denoting all VLANs or zero VLANs being configured on a trunk.

#### vlan-graph.j2
Template file for generating the .dot graph description. At this point the nodes and interfaces are hardcoded, making it a fabric template of sorts. Jinja2 logic color codes edges based on the presence of a active VLAN on that trunk. Each node has two directional edges connecting them, representing the configuration of each interface on the trunk; allows quick identification of mismatched allowed VLANs.

Could be expanded to abstract the graph logic from the fabric definition, perhaps allowing for automated fabric discovery via CDP/LLDP. Needs to be expanded to include router dot1q subinterfaces. Could be expanded to include access ports, but would require the abstraction of the fabric and/or automated discovery. Also could do with some cleanup of the structure to make interface names more readable, especially around the vpls node.

#### parse-trunk-members.filter
This filter definition is used with the parse_cli filter. It expects the input to be the string result of 'show interfaces trunk' on a Cisco IOS switch. Using regex it extracts the interface names of any configured trunks and a string of the allowed VLANs on the trunk. The filter starts on the second block, which only includes VLANs within the management domain (i.e. explicitely configured on the switch when vtp is in transparent mode). It returns these values as dictionaries stored within a fact. My lab does not require STP, but in a network that does it might be better to parse over the third block, which shows VLANs in forwarding state on that trunk.

#### build-vlan-diagram.yml
The playbook use as the executable; the desired VLAN to draw a diagram is specified as -e vlan=*vlan*. The input is converted to an int, or is set to VLAN 1 as a default. template (for the graph definition), dotOutput and pngOutput are also valid variables. By default the .dot and .png files are placed in ./diagrams.

- Task: Retrieve trunk data
   This task logs into each host defined for the play and executes the command 'show interface trunk' and registers the output.

- Task: Parse cli output
   The data registered in the first task is filtered through parse_cli using the parse-trunk-members.filter filter and stores the parsed data as facts.

- Task: Create default output dir
   This task creates ./diagrams/ if it doesn't already exist. Prevents error when saving outputs in default locations. Doesn't help if custom output points towards non-existent directory.

- Task: Generate graph file
   The vlan-graph.j2 file descibes the switching fabric but is also the template for generating the DOT files. It checks to see whether a particular interface has the defined VLAN present and colours the edge appropriately; red if the VLAN is present on the trunk, gray if it is not. The resulting DOT file is saved in dotOutput or ./diagrams/.
   
- Task: Render graph
   Finally, the DOT file created in the templating step is generated by graphviz and the resulting PNG saved to pngOutput or ./diagrams/. There is no logic to check if graphviz is installed, currently.
   
###Future plans
The next step of development should be to abstract the fabric definition away from the graph generation logic. Once that is complete it would be good to generate that fabric definition file from either stored configs or freshly hunted wild configs/LLDP neighbors.

I'd also like to include dot1q subinterfaces from the routers and include access ports, perhaps as a tooltip over the nodes, listing the access ports.

Much of the VLAN gathering logic could also be used for config remediation or alerting on unmatched trunk config.
